import { useEditorStore } from '../store/useEditorStore';
import type { EditorElement, EditorGroup } from '../store/useEditorStore';

/**
 * Human-friendly export schema using an assets map.
 */
export type ExportAsset = {
  id: string;
  type: 'image' | string;
  fileName?: string;
  dataUrl?: string; // optional if remote
  src?: string; // remote URL
};

export type ExportElement = {
  id: string;
  type: EditorElement['type'] | 'group';
  groupId?: string | null;
  // all element-specific fields (x, y, width, height, zIndex, text, etc.) live inside properties
  properties?: Record<string, any>;
};

export type ExportGroup = EditorGroup & { elements?: ExportElement[] };

export type ExportCanvas = {
  id: string;
  width: number;
  height: number;
  backgroundAssetId?: string;
  backgroundSrc?: string;
  backgroundRepeat?: boolean;
  canvasMeta?: string;
  canvasTtsModel?: string;
  elements: ExportElement[];
};

export type ExportProject = {
  version: 1;
  createdAt: string;
  app: { name: string; version?: string };
  notes?: string;
  // support multiple canvases in the future; current export will create a single canvas inside this array
  canvases: ExportCanvas[];
  // legacy: older exports may include an `assets` map. New exports inline image `src` on elements.
  assets?: Record<string, ExportAsset>;
};

// (no-op) helper removed â€” images are inlined as `src` on image elements in the new format

/**
 * Serialize the current editor state into a human-friendly export with assets map.
 */
export function serializeProject(): ExportProject {
  const s = useEditorStore.getState();

  // Canvas background: keep the canvasBackground value (data URL or remote URL) inline on the canvas
  const bgSrc = s.canvasBackground ?? null;

  // Map elements into grouped children and ungrouped list
  const groupedMap: Record<string, ExportElement[]> = {};
  const ungrouped: ExportElement[] = [];

  (s.elements || []).forEach((el) => {
    const z = (s.elements || []).findIndex((ee) => ee.id === el.id);
    const base: ExportElement = {
      id: el.id,
      type: el.type,
      groupId: el.groupId ?? null,
      properties: {
        x: el.x,
        y: el.y,
        width: el.width,
        height: el.height,
        zIndex: z >= 0 ? z : undefined,
      } as Record<string, any>,
    };

    // Merge element-specific properties into the properties object
    if (el.type === 'text' || el.type === 'rectangle') {
      Object.assign(base.properties as Record<string, any>, {
        text: el.text ?? '',
        aiText: el.aiText ?? undefined,
        fontSize: el.fontSize,
        fontFamily: el.fontFamily,
        fontColor: el.fontColor,
        bold: el.bold,
        italic: el.italic,
        underline: el.underline,
        align: el.align,
        fillColor: el.fillColor,
        cornerRadius: el.cornerRadius,
      });
    }

    if (el.type === 'image') {
      // Prefer plain src (remote URL). If src is a data URL (local upload), keep it inline since there's no external URL.
      if (el.src) {
        Object.assign(base.properties as Record<string, any>, { src: el.src, fileName: el.fileName });
      }
    }

    if (el.type === 'aiImage') {
      Object.assign(base.properties as Record<string, any>, { aiImagePrompt: el.aiImagePrompt ?? '', text: el.text ?? '' });
    }

    if (el.groupId) {
      groupedMap[el.groupId] = groupedMap[el.groupId] || [];
      groupedMap[el.groupId].push(base);
    } else {
      ungrouped.push(base);
    }
  });

  const out: ExportProject = {
    version: 1,
    createdAt: new Date().toISOString(),
  app: { name: 'reelMakerAI', version: undefined },
    notes: 'Export generated by reelMakerAI',
    canvases: [
      {
        id: 'canvas_' + crypto.randomUUID(),
  width: s.canvasWidth,
  height: s.canvasHeight,
  // store background src inline (could be data URL or remote URL)
  backgroundSrc: bgSrc ?? undefined,
  backgroundRepeat: !!s.canvasBackgroundRepeat,
  canvasMeta: s.canvasMeta || undefined,
  canvasTtsModel: s.canvasTtsModel || undefined,
        elements: [
          // first, export groups as elements of type 'group' with children
          ...Object.values(s.groups || {}).map((g) => ({
            id: g.id,
            type: 'group' as any,
            groupId: null,
            properties: {
              // compute a zIndex for the group based on its children's zIndex (min)
              zIndex: (groupedMap[g.id] || []).reduce((acc, e) => (typeof e.properties?.zIndex === 'number' ? Math.min(acc, e.properties.zIndex as number) : acc), Number.MAX_SAFE_INTEGER) || 0,
              ...g,
            } as Record<string, any>,
            // attach child elements inside the group element
            elements: groupedMap[g.id] || [],
          } as any)),
          // then ungrouped elements
          ...ungrouped,
        ],
      },
    ],
    // no top-level assets by default (images are inlined as `src` on image elements). Keep legacy support by optionally including `assets` if needed.
  };

  return out;
}

/**
 * Deserialize an ExportProject object (v1) and restore into the store.
 * This will overwrite elements/groups/canvas. Caller should confirm before calling.
 */
export async function deserializeProject(obj: unknown): Promise<void> {
  if (!obj || typeof obj !== 'object') throw new Error('Invalid project JSON');
  const project = obj as Partial<ExportProject>;
  if (project.version !== 1) throw new Error('Unsupported project version: ' + String(project.version));
  // Support both new `canvases` array and legacy single `canvas` + top-level `elements`
  const assets = project.assets || {};
  const canvases = (project as any).canvases as ExportCanvas[] | undefined;
  const legacyCanvas = (project as any).canvas as any | undefined;
  const legacyElements = (project as any).elements as ExportElement[] | undefined;
  if (!canvases && (!legacyCanvas || !legacyElements)) throw new Error('Malformed project JSON');

  // helper to resolve assetId or src
  function resolveImage(properties: any) {
    if (!properties) return { src: undefined, fileName: undefined };
    if (properties.assetId && assets[properties.assetId] && assets[properties.assetId].dataUrl) {
      return { src: assets[properties.assetId].dataUrl, fileName: assets[properties.assetId].fileName };
    }
    if (properties.src) return { src: properties.src, fileName: properties.fileName };
    return { src: undefined, fileName: properties.fileName };
  }

  // recreate elements in the shape of EditorElement
  // elements may include group elements (type === 'group') which contain children
  // Prefer new canvases[0].elements; fall back to legacy top-level elements
  const projectElements: ExportElement[] = (canvases && canvases.length > 0) ? (canvases[0].elements || []) : (legacyElements || []);

  const elementsFromGroups: ExportElement[] = [];
  const groupsArrayFromElements: ExportGroup[] = [];
  for (const pe of projectElements) {
    if ((pe as any).type === 'group') {
      const grpProps = (pe as any).properties || {};
      groupsArrayFromElements.push({ ...(grpProps as ExportGroup), id: pe.id } as ExportGroup);
      const children = (pe as any).elements || [];
      for (const c of children) {
        // ensure grouped children carry the group's id so they can be restored with groupId
        c.groupId = pe.id;
        elementsFromGroups.push(c);
      }
    }
  }

  const topLevelElements = projectElements.filter((e) => (e as any).type !== 'group');
  const allExportElements: ExportElement[] = [...topLevelElements, ...elementsFromGroups];

  // sort by properties.zIndex (if present) to rebuild the global stacking order
  const sorted = allExportElements.slice().sort((a, b) => {
    const za = typeof a.properties?.zIndex === 'number' ? a.properties!.zIndex as number : 0;
    const zb = typeof b.properties?.zIndex === 'number' ? b.properties!.zIndex as number : 0;
    return za - zb;
  });

  const elements: EditorElement[] = sorted.map((el) => {
    const props = el.properties || {};
    const common: Partial<EditorElement> = {
      id: el.id,
      type: el.type as any,
      groupId: el.groupId ?? undefined,
      x: props.x,
      y: props.y,
      width: props.width,
      height: props.height,
    };
    if (el.type === 'text' || el.type === 'rectangle') {
      Object.assign(common, {
        text: props.text ?? '',
        aiText: props.aiText ?? undefined,
        fontSize: props.fontSize,
        fontFamily: props.fontFamily,
        fontColor: props.fontColor,
        bold: props.bold,
        italic: props.italic,
        underline: props.underline,
        align: props.align,
        fillColor: props.fillColor,
        cornerRadius: props.cornerRadius,
      });
    }

    if (el.type === 'image') {
      const resolved = resolveImage(props);
      Object.assign(common, { src: resolved.src, fileName: resolved.fileName });
    }

    if (el.type === 'aiImage') {
      Object.assign(common, { aiImagePrompt: props.aiImagePrompt ?? '', text: props.text ?? '' });
    }

    return common as EditorElement;
  });


  // Build groups record from extracted groups
  const groupsRecord: Record<string, EditorGroup> = {};
  for (const g of groupsArrayFromElements) {
    if (!g.id) continue;
    groupsRecord[g.id] = g as EditorGroup;
  }

  // determine which canvas metadata to apply (new or legacy)
  const canvasToApply = (canvases && canvases.length > 0) ? canvases[0] : legacyCanvas;

  // apply to store
  useEditorStore.setState({
    elements,
    groups: groupsRecord,
    canvasWidth: canvasToApply.width,
    canvasHeight: canvasToApply.height,
    canvasBackground: canvasToApply.backgroundAssetId ? assets[canvasToApply.backgroundAssetId!]?.dataUrl ?? null : canvasToApply.backgroundSrc ?? null,
    canvasBackgroundRepeat: !!canvasToApply.backgroundRepeat,
    canvasMeta: canvasToApply.canvasMeta || '',
    selectedId: null,
    selectedGroupId: null,
    showCanvaProperties: false,
  } as any);

  return;
}
