import { useEditorStore } from '../store/useEditorStore';
import type { EditorElement, EditorGroup } from '../store/useEditorStore';

/**
 * Human-friendly export schema using an assets map.
 */
export type ExportAsset = {
  id: string;
  type: 'image' | string;
  fileName?: string;
  dataUrl?: string; // optional if remote
  src?: string; // remote URL
};

export type ExportElement = {
  id: string;
  type: EditorElement['type'] | 'group';
  groupId?: string | null;
  // all element-specific fields (x, y, width, height, zIndex, text, etc.) live inside properties
  properties?: Record<string, any>;
};

export type ExportGroup = EditorGroup & { elements?: ExportElement[] };

export type ExportProject = {
  version: 1;
  createdAt: string;
  app: { name: string; version?: string };
  notes?: string;
  canvas: {
    width: number;
    height: number;
    backgroundAssetId?: string;
    backgroundSrc?: string;
    backgroundRepeat?: boolean;
    canvasMeta?: string;
  };
  assets: Record<string, ExportAsset>;
  // elements contains both regular elements and group elements (type === 'group')
  elements: ExportElement[];
};

function isDataUrl(s?: string | null) {
  return !!s && typeof s === 'string' && s.startsWith('data:');
}

/**
 * Serialize the current editor state into a human-friendly export with assets map.
 */
export function serializeProject(): ExportProject {
  const s = useEditorStore.getState();

  const assets: Record<string, ExportAsset> = {};
  const dataUrlToAssetId: Record<string, string> = {};

  function ensureAssetFromDataUrl(dataUrl?: string | null, fileName?: string) {
    if (!dataUrl) return undefined;
    if (!isDataUrl(dataUrl)) return undefined;
    if (dataUrlToAssetId[dataUrl]) return dataUrlToAssetId[dataUrl];
    const id = 'asset_' + crypto.randomUUID();
    dataUrlToAssetId[dataUrl] = id;
    assets[id] = { id, type: 'image', fileName: fileName || undefined, dataUrl };
    return id;
  }

  // Canvas background
  const bgAssetId = ensureAssetFromDataUrl(s.canvasBackground ?? null, undefined);

  // Map elements into grouped children and ungrouped list
  const groupedMap: Record<string, ExportElement[]> = {};
  const ungrouped: ExportElement[] = [];

  (s.elements || []).forEach((el) => {
    const z = (s.elements || []).findIndex((ee) => ee.id === el.id);
    const base: ExportElement = {
      id: el.id,
      type: el.type,
      groupId: el.groupId ?? null,
      properties: {
        x: el.x,
        y: el.y,
        width: el.width,
        height: el.height,
        zIndex: z >= 0 ? z : undefined,
      } as Record<string, any>,
    };

    // Merge element-specific properties into the properties object
    if (el.type === 'text' || el.type === 'rectangle') {
      Object.assign(base.properties as Record<string, any>, {
        text: el.text ?? '',
        aiText: el.aiText ?? undefined,
        fontSize: el.fontSize,
        fontFamily: el.fontFamily,
        fontColor: el.fontColor,
        bold: el.bold,
        italic: el.italic,
        underline: el.underline,
        align: el.align,
        fillColor: el.fillColor,
        cornerRadius: el.cornerRadius,
      });
    }

    if (el.type === 'image') {
      if (isDataUrl(el.src)) {
        const aid = ensureAssetFromDataUrl(el.src, el.fileName);
        if (aid) Object.assign(base.properties as Record<string, any>, { assetId: aid, fileName: el.fileName });
      } else if (el.src) {
        Object.assign(base.properties as Record<string, any>, { src: el.src, fileName: el.fileName });
      }
    }

    if (el.type === 'aiImage') {
      Object.assign(base.properties as Record<string, any>, { aiImagePrompt: el.aiImagePrompt ?? '', text: el.text ?? '' });
    }

    if (el.groupId) {
      groupedMap[el.groupId] = groupedMap[el.groupId] || [];
      groupedMap[el.groupId].push(base);
    } else {
      ungrouped.push(base);
    }
  });

  const out: ExportProject = {
    version: 1,
    createdAt: new Date().toISOString(),
  app: { name: 'reelMakerAI', version: undefined },
    notes: 'Export generated by reelMakerAI',
    canvas: {
      width: s.canvasWidth,
      height: s.canvasHeight,
      backgroundAssetId: bgAssetId ?? undefined,
      backgroundSrc: !bgAssetId && s.canvasBackground ? s.canvasBackground : undefined,
      backgroundRepeat: !!s.canvasBackgroundRepeat,
      canvasMeta: s.canvasMeta || undefined,
    },
    assets,
    elements: [
      // first, export groups as elements of type 'group' with children
      ...Object.values(s.groups || {}).map((g) => ({
        id: g.id,
        type: 'group' as any,
        groupId: null,
        properties: {
          // compute a zIndex for the group based on its children's zIndex (min)
          zIndex: (groupedMap[g.id] || []).reduce((acc, e) => (typeof e.properties?.zIndex === 'number' ? Math.min(acc, e.properties.zIndex as number) : acc), Number.MAX_SAFE_INTEGER) || 0,
          ...g,
        } as Record<string, any>,
        // attach child elements inside the group element
        elements: groupedMap[g.id] || [],
      } as any)),
      // then ungrouped elements
      ...ungrouped,
    ],
  };

  return out;
}

/**
 * Deserialize an ExportProject object (v1) and restore into the store.
 * This will overwrite elements/groups/canvas. Caller should confirm before calling.
 */
export async function deserializeProject(obj: unknown): Promise<void> {
  if (!obj || typeof obj !== 'object') throw new Error('Invalid project JSON');
  const project = obj as Partial<ExportProject>;
  if (project.version !== 1) throw new Error('Unsupported project version: ' + String(project.version));
  if (!project.canvas || !project.elements) throw new Error('Malformed project JSON');

  const assets = project.assets || {};

  // helper to resolve assetId or src
  function resolveImage(properties: any) {
    if (!properties) return { src: undefined, fileName: undefined };
    if (properties.assetId && assets[properties.assetId] && assets[properties.assetId].dataUrl) {
      return { src: assets[properties.assetId].dataUrl, fileName: assets[properties.assetId].fileName };
    }
    if (properties.src) return { src: properties.src, fileName: properties.fileName };
    return { src: undefined, fileName: properties.fileName };
  }

  // recreate elements in the shape of EditorElement
  // elements may include group elements (type === 'group') which contain children
  const projectElements: ExportElement[] = project.elements || [];

  const elementsFromGroups: ExportElement[] = [];
  const groupsArrayFromElements: ExportGroup[] = [];
  for (const pe of projectElements) {
    if ((pe as any).type === 'group') {
      const grpProps = (pe as any).properties || {};
      groupsArrayFromElements.push({ ...(grpProps as ExportGroup), id: pe.id } as ExportGroup);
      const children = (pe as any).elements || [];
      for (const c of children) {
        // ensure grouped children carry the group's id so they can be restored with groupId
        c.groupId = pe.id;
        elementsFromGroups.push(c);
      }
    }
  }

  const topLevelElements = projectElements.filter((e) => (e as any).type !== 'group');
  const allExportElements: ExportElement[] = [...topLevelElements, ...elementsFromGroups];

  // sort by properties.zIndex (if present) to rebuild the global stacking order
  const sorted = allExportElements.slice().sort((a, b) => {
    const za = typeof a.properties?.zIndex === 'number' ? a.properties!.zIndex as number : 0;
    const zb = typeof b.properties?.zIndex === 'number' ? b.properties!.zIndex as number : 0;
    return za - zb;
  });

  const elements: EditorElement[] = sorted.map((el) => {
    const props = el.properties || {};
    const common: Partial<EditorElement> = {
      id: el.id,
      type: el.type as any,
      groupId: el.groupId ?? undefined,
      x: props.x,
      y: props.y,
      width: props.width,
      height: props.height,
    };
    if (el.type === 'text' || el.type === 'rectangle') {
      Object.assign(common, {
        text: props.text ?? '',
        aiText: props.aiText ?? undefined,
        fontSize: props.fontSize,
        fontFamily: props.fontFamily,
        fontColor: props.fontColor,
        bold: props.bold,
        italic: props.italic,
        underline: props.underline,
        align: props.align,
        fillColor: props.fillColor,
        cornerRadius: props.cornerRadius,
      });
    }

    if (el.type === 'image') {
      const resolved = resolveImage(props);
      Object.assign(common, { src: resolved.src, fileName: resolved.fileName });
    }

    if (el.type === 'aiImage') {
      Object.assign(common, { aiImagePrompt: props.aiImagePrompt ?? '', text: props.text ?? '' });
    }

    return common as EditorElement;
  });


  // Build groups record from extracted groups
  const groupsRecord: Record<string, EditorGroup> = {};
  for (const g of groupsArrayFromElements) {
    if (!g.id) continue;
    groupsRecord[g.id] = g as EditorGroup;
  }

  // apply to store
  useEditorStore.setState({
    elements,
    groups: groupsRecord,
    canvasWidth: project.canvas!.width,
    canvasHeight: project.canvas!.height,
    canvasBackground: project.canvas!.backgroundAssetId ? assets[project.canvas!.backgroundAssetId!]?.dataUrl ?? null : project.canvas!.backgroundSrc ?? null,
    canvasBackgroundRepeat: !!project.canvas!.backgroundRepeat,
    canvasMeta: project.canvas!.canvasMeta || '',
    selectedId: null,
    selectedGroupId: null,
    showCanvaProperties: false,
  } as any);

  return;
}
